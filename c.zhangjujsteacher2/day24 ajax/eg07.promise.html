<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>
        // Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。
        // 它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。

        // Promise对象有以下两个特点。
        // （ 1） 对象的状态不受外界影响。 
        //  Promise对象代表一个异步操作， 有三种状态： pending（ 进行中）、 fulfilled（ 已成功） 和rejected（ 已失败）。
        //  只有异步操作的结果， 可以决定当前是哪一种状态， 任何其他操作都无法改变这个状态。 
        //  这也是Promise这个名字的由来， 它的英语意思就是“ 承诺”， 表示其他手段无法改变。

        // （ 2） 一旦状态改变， 就不会再变， 任何时候都可以得到这个结果。                     
        // Promise对象的状态改变， 只有两种可能： 从pending变为fulfilled和从pending变为rejected。 
        // 只要这两种情况发生， 状态就凝固了， 不会再变了， 会一直保持这个结果， 这时就称为 resolved（ 已定型）。 
        // 如果改变已经发生了， 你再对Promise对象添加回调函数， 也会立即得到这个结果。   
        // 这与事件（ Event） 完全不同， 事件的特点是， 如果你错过了它， 再去监听， 是得不到结果的。

        console.log(1);
        let p = new Promise((resolve /*成功*/ , reject /*失败*/ ) => {
            // 函数是一个prmise容器
            // 内部存储一个需要执行的异步操作
            // 这个容器内的代码是同步执行的
            console.log(2);
            let num = '15';
            if (typeof num === 'number') {
                resolve(true); // 将promise的状态从 进行中 变成 已成功
            }

            reject(false); // 将promise的状态从 进行中 变成 已失败
        });
        console.log(3);

        // console.log(p);

        // then 和 catch 是异步的
        p.then(value => { // 当promise状态为 已成功时 会执行then中的回调函数        
            // 参数是 resolve 传递的参数
            // console.log(value);
            console.log(4);
        }).catch(value => { // 当promise的状态 为 已失败时  则会执行catch中的回调函数
            // 参数是 reject 传递的参数
            // console.log(value);
            console.log(5);
        });
        console.log(6);
    </script>
</head>

<body>

</body>

</html>