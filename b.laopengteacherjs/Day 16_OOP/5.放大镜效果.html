<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            padding: 0px;
            margin: 0px;
        }
        
        .scale {
            margin: 30px 0 0 50px;
        }
        
        .spic {
            width: 400px;
            height: 400px;
            border: 1px solid #ccc;
            position: relative;
            float: left;
        }
        
        .spic img {
            width: 400px;
            height: 400px;
            display: block;
        }
        
        .sf {
            opacity: 0.3;
            background-color: orange;
            position: absolute;
            left: 0px;
            top: 0px;
            visibility: hidden;
            cursor: move;
        }
        
        .bf {
            width: 500px;
            height: 500px;
            border: 1px solid #ccc;
            float: left;
            overflow: hidden;
            margin-left: -1px;
            position: relative;
            visibility: hidden;
        }
        
        .bpic {
            width: 800px;
            height: 800px;
            position: absolute;
            left: 0px;
            top: 0px;
        }
    </style>
</head>

<body>
    <div class="scale">
        <div class="spic">
            <!-- 小图 -->
            <img src="scale.jpg" alt="">
            <div class="sf"></div>
            <!-- 小放 -->
        </div>
        <div class="bf">
            <!-- 大放 -->
            <img src="scale.jpg" alt="" class="bpic">
            <!-- 大图 -->
        </div>
    </div>
</body>
<script>
    //放大镜效果公式：
    // 大图/小图 = 大放/小放
    // 大图/大放 = 小图/小放
    class Scale {
        constructor() { //构造函数
            //1.获取元素
            this.scale = document.querySelector('.scale');
            this.spic = document.querySelector('.spic');
            this.sf = document.querySelector('.sf');
            this.bf = document.querySelector('.bf');
            this.bpic = document.querySelector('.bpic');
        }
        init() {
            //1.鼠标移入小图，小放和大放显示，否则隐藏
            this.scale.onmouseover = () => {
                this.sf.style.visibility = 'visible';
                this.bf.style.visibility = 'visible';
                this.spic.onmousemove = (ev) => {
                    var ev = ev || window.event;
                    let left = ev.clientX - this.scale.offsetLeft - this.sf.offsetWidth / 2;
                    let top = ev.clientY - this.scale.offsetTop - this.sf.offsetHeight / 2;
                    if (left <= 0) {
                        left = 0;
                    } else if (left >= this.spic.offsetWidth - this.sf.offsetWidth) {
                        left = this.spic.offsetWidth - this.sf.offsetWidth;
                    }

                    if (top <= 0) {
                        top = 0;
                    } else if (top >= this.spic.offsetHeight - this.sf.offsetHeight) {
                        top = this.spic.offsetHeight - this.sf.offsetHeight;
                    }

                    //求比例
                    this.bili = this.bpic.offsetWidth / this.spic.offsetWidth;


                    this.sf.style.left = left + 'px'; //减去scale盒子的位置。
                    this.sf.style.top = top + 'px';

                    this.bpic.style.left = -this.bili * left + 'px';
                    this.bpic.style.top = -this.bili * top + 'px';
                }
            };

            this.scale.onmouseout = () => {
                this.sf.style.visibility = 'hidden';
                this.bf.style.visibility = 'hidden';
            };
            //2.求小放的尺寸。
            this.sf.style.width = this.spic.offsetWidth * this.bf.offsetWidth / this.bpic.offsetWidth + 'px';
            this.sf.style.height = this.spic.offsetHeight * this.bf.offsetHeight / this.bpic.offsetHeight + 'px';

        }
    }

    new Scale().init();
</script>
<script>
    //class编写放大镜效果。
    //混合开发：构造函数+原型
    function Fn(num) {
        this.num = num;
    }

    Fn.prototype.show = function() {
        return this.num;
    }

    let f1 = new Fn(200);
    console.log(f1.show());


    //class开发
    class Fn1 {
        constructor(num) { //构造函数
            this.num = num;
        }
        show() {
            return this.num;
        }
    }

    let f2 = new Fn1(400);
    console.log(f2.show());

    console.log(typeof Fn); //function
    console.log(typeof Fn1); //function   class就是构造函数的语法糖
</script>

</html>